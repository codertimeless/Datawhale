## MySQL day1 Basic Theory

### 1. 数据库基础知识

####      1.1 数据库是什么？

​       在思考数据库是什么之前，我们不妨先想想，什么是 **数据** 呢？ 我们都知道计算机只能存储二进制文件，CPU只认识二进制，也就是 0 和 1，是不同于人的大脑，能记下更多的抽象化的东西，比如说你的感受。

​        但是计算机的优势能够存储下大量的数据。那么它只认识二进制，那么我们要怎么样才能保存下我们需要的 **信息** 呢，这个时候我们就要将需要保存的信息进行特殊的加工处理，比如说声音：我们经过处理，就能把一段声音以二进制文件保存下来。

​        数据库，简而言之可视为电子化的文件柜——存储电子文件的处所，用户可以对文件中的数   据进行新增、查询、更新、删除等操作。

​        所谓“数据库”是以 **一定方式** 储存在一起、能与多个用户 **共享**、具有尽可能小的 **冗余度**、与应用程序彼此独立的数据 **集合**。

​        数据管理在发展过程中，共有三个比较重要的阶段：(1)人工管理阶段，这个时候计算机特征是硬件受限，可用空间只有寥寥几KB，编程语言只有汇编语言。在这个阶段，计算机主要用来进行科学计算，根本没有软件这一说，使用者将需要计算的数据手工输入，然后计算机输出后，使用者记下数据，关闭，没有保留数据这一流程；

(2) 操作系统初期，这个阶段的主要特征是出现了操作系统，硬件水平得到了很多的发展，计算机不仅仅局限于科学计算，体积相对于早期也小了很多，开始有了文件系统，人们可以通过文件系统的形式将计算机运算的结果进行保存。但文件系统的局限在于共享性较差，且冗余度较高，不利于数据的存储，我们要花费大量的存储空间来说明数据；

(3) 数据库系统，由于硬件设备的进一步发展，以及软件开发的发展，计算机有了越来越多的用途。然而，在开发过程中，我们很多时候数据是需要共享的，而且我们希望每个应用程序之间的数据能够独立起来，这样我们的数据就能更好地保存，使用。这个时候关系型数据库的出现，就解决了很大程度上软件开发者的需求，通过分表能有效降低冗余度，又能通过外键进行关联；可供用户共享。

#### 1.2 关系型数据库

​       关系型数据库是建立在 **关系模型** 之上的，而关系模型是指若干个存储数据的表格，可以把它们表的每一 **行** 称为 **记录 (record) **，记录是一个逻辑意义上的数据，也就是说在关系型数据库中我们的数据是以行为基础单位进行保存的。

​       表的每一列称为 **字段** ，同一个表的每一行记录都拥有相同的若干字段。意思是字段定义了我们这个表格当中要存储什么样的数据。

​       **主键** 是一种通用表级约束，在一个表格中必须要设置主键，主键在每个表格中必须是独一无二的，用来区分每一行数据。

​        **外键** 可以将两个表格中的某一行数据彼此关联起来，这样做的好处是可以很大程度上减小冗余度。

### 2. MySQL数据库管理系统

创建数据库系统：

```
CREATE DATABASE DB_name CHARACTER SET utf8;
```

创建数据表：

```
CREATE TABLE STUDENS(
     id int unsigned not null auto_increment primary key,
     name char(8) not null,
     sex char(4) not null,
     age tinyint not null,
     tel char(11) null default "-"
)            
```

#### 2 .1 MySQL 数据类型

##### 1. 整数

| MySQL数据类型 | 含义（有符号）                          |
| ------------- | --------------------------------------- |
| tinyint(m)    | 1个字节 范围（-128, 127）               |
| smallint(m)   | 2个字节 范围（-32768，32767）           |
| mediumint(m)  | 3个字节 范围（-8388608，8288607）       |
| int(m)        | 4个字节 范围（-2147483648，2147483647） |
| bigint(m)     | 8个字节 范围（+-9.22*10^18)             |

取值范围如果加了 unsigned ,则最大值翻倍，如 tinyint unsigned 的取值范围为（0，256）。

int(m) 里的 m 是表示 SELECT 查询结果集中的显示宽度，并不影响实际的取值范围。

##### 2. 浮点型(float 和 double)

| MySQL 数据类型 | 含义                                                  |
| -------------- | ----------------------------------------------------- |
| float(m,d)     | 单精度浮点型，8位精度 (4字节)   m是总位数，d为小数位  |
| double(m,d)    | 双精度浮点型，16位精度（8字节）  m是总位数，d为小数位 |

假设一个字段定义为 `float(5,3)`，如果插入一个数 123.45678，实际数据库里寸的是 123.457，但总个数还是以实际为准，即6位。

##### 3. 定点数(decimal)

 1.浮点数在数据库中存放的是近似值，而定点类型在数据库中存放的是精确值。

 2.` decimal(m,d)` 其中参数 m < 65 是总个数，d < 30 且 d < m是小数位。

##### 4. 字符串(char, varchar, text)

| MySQL数据类型 | 含义                        |
| ------------- | --------------------------- |
| char(n)       | 固定长度，最多255个字符     |
| varchar(n)    | 固定长度，最多65535个字符   |
| tinytext      | 可变长度，最多255字符       |
| text          | 可变长度，最多65535个字符   |
| mdiumtext     | 可变长度，最多2^24 -1个字符 |
| longtext      | 可变长度，最多2^32-1个字符  |

- char 和 varchar 的区别：

1.char(n) 若存入字符数小于 n，则以空格补于其后，查询时再将空格去掉。所以 char 类型存储的字符串末尾不能有空格，varchar 不限于此；

2.char(n) 固定长度，char(4) 不管是存入几个字符，都将占用 4 个字节;varchar 是存入的实际字符数 + 1个字节(n <= 255) 或 2 个字节(n > 255)，所以 varchar(4) 存入3 个字符将占用 4 个字 节；

3.char 类型的字符串检索速度比 varchar 类型快；

- varchar 和 text的区别：

1.varchar可指定n，text不能指定，内部存储varchar是存入的实际字符数+1个字节（n<=255）或2个字节(n>255)，text是实际字符数+2个字节。 
2.text类型不能有默认值。 
3.varchar可直接创建索引，text创建索引要指定前多少个字符。varchar查询速度快于text,在都创建索引的情况下，text的索引似乎不起作用。

##### 5. 二进制类型(Blob)

1.BLOB 和 text 存储方式不同，TEXT 以文本方式存储，英文存储区分大小写，而Blob是以二进制方式存储，不分大小写。 
2.BLOB 存储的数据只能整体读出。 
3.TEXT 可以指定字符集，BLOB 不用指定字符集。

##### 6. 日期时间类型

| **MySQL数据类型** | **含义**                      |
| ----------------- | ----------------------------- |
| date              | 日期 '2008-12-2'              |
| time              | 时间 '12:25:36'               |
| datetime          | 日期时间 '2008-12-2 22:06:44' |
| timestamp         | 自动存储记录修改时间          |

若定义一个字段为timestamp，这个字段里的时间数据会随其他字段修改的时候自动刷新，所以这个数据类型的字段可以存放这条记录最后被修改的时间。

#### 2.2 字段约束

| **MySQL关键字**    | **含义**                 |
| ------------------ | ------------------------ |
| NULL               | 数据列可包含NULL值       |
| NOT NULL           | 数据列不允许包含NULL值   |
| DEFAULT            | 默认值                   |
| PRIMARY KEY        | 主键                     |
| AUTO_INCREMENT     | 自动递增，适用于整数类型 |
| UNSIGNED           | 无符号                   |
| CHARACTER SET name | 指定一个字符集           |

### 3. 数据查询

SELECT语法的基本语法为：

```sql
SELECT [ALL | DISTINCT] col_name [,...expression...]
FROM table_name [,table2_name,view_name...]
[WHERE condition]
[GROUP BY col_name1 [,col_name2,...]  
[HAVING group_condition]
[ORDER BY col_name2] [ASC | DESC] [,col_name3],...]
```

一条SQL查询语句的执行顺序：

 1.根据 `WHERE` 子句的条件表达式 condition ，从 `FROM` 子句指定的基本表或视图中找出满足条件的记录；

2.再按照 `SELECT `子句中目标列或者表达式，形成结果表；

3.如果有 `GROUP BY` 子句，则将结果按特定列进行分组，如果 group 子句带有 HAVING 子句，则只有满足指定条件 group_condition 的组才会返回；

4.如果有 `ORDER BY `子句，则对返回的结果进行排序。

- 去重：`DISTINCT` 将数据去重，当在句首使用该语句后，所有筛选结果都会被去重；
- 前N个：`LIMIT N, OFFSET M`，前N个，选M个；

#### 3.1 聚集函数

- AVG(): 求平均值
- MIN(): 求最小值
- MAX(): 求最大值
- COUNT(): 求行数
- SUM(): 求列值的和

#### 3.2文本处理函数

- Left(): 返回串左边的字符
- Length(): 返回串的长度
- Locate(): 找出串的一个子串

- Lower(): 将串转换为小写
- LTrim(): 去掉串左边的空格
- Right(): 返回串左边的字符
- RTrim(): 去掉传右边的空格
- Soundex(): 返回串的 SOUNDEX 值，也就是读音接近的值
- SubString(): 返回子串的字符
- Upper(): 将串转换为大写

#### 3.3 日期和时间处理函数

日期和时间采用相应的数据类型和特殊的格式存储，以便能快速和有效的排序和过滤，并且节省物理存储空间。

无论什么时候指定一个日期，不管是插入或更新表值还是使用 WHERE 子句进行过滤，日期格式必须为 yyyy-MM-dd，用来排除多义性。

但是在我们用日期进行查询时，有可能会发生这样的错误：我们保存的数据类型为 datetime，也就是说保存的格式为 yyyy-MM-dd HH:mm:ss，但是我们在查询过程中，往往不会使用到具体的时间，更多的是日期，在某一个大的时间段内，那么我们在查询 `where order_time = '2015-05-20'` 的时候，将无法进行匹配。

这个时候，我们就需要日期函数来进行比对，Date(order_time) 就能提取列的日期部分。相对应的，加入我们只需要提取时间，则可以使用 Time(order_time) 提取该列的时间部分。

- Day()：返回一个日期的天数部分
- Hour():  返回一个时间的小时部分
- Minute():  返回一个时间的分钟部分
- Sencond():  返回一个时间的秒部分
- Year():  返回一个日期的年份部分
- Month():  返回一个日期的月份部分
- Curtime():  返回当前时间
- CurDate():  返回当前日期
- DayOfWeek():  对于一个日期，返回对应的星期几
- AddDate():  增加一个日期
- AddTime():  增加一个时间
- DateDiff():  返回两个日期之差
- Date_Add():  高度灵活的日期运算函数

### 作业

```sql
SELECT Email
FROM email
GROUP BY Email
HAVING COUNT(Email) > 1
```

```sql
SELECT name,population,area
FROM World
WHERE population > 3000000 or (population > 25000000 and gdp > 20000000)
```

